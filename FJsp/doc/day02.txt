day02

프로젝트 폴더의 구조
	Java Resource
		==> JSP가 사용할 자바 소스코드(클래스)를 코딩하는 위치
			Java Resource/src/필요한 패키지를 만들고
			그 내부에 클래스를 만들어서 사용하면 된다.
	
	WebContent
		==> 이 위치가 실제 JSP나 또는 HTML, 자바스크립트, CSS 등
			응답에 필요한 문서르 작성하는 위치
			
			웹서버가 직접 요청하는 문서를 저장하는 폴더
			
		WEB-INF
			==> Servlet프로그램에 의해서 요청하는 문서를 저장하는 폴더
				
		해당 위치를 기본폴더로 해서 원하는 폴더를 만든 후 
		그 폴더에 필요한 문서를 만들면 된다.
		
		예제]
			WebContent 아래에 sample폴더를 만들고
			그 폴더에 sample.jsp 파일을 만들어 테스트한다.
			
			문서요청은
			우리의 경우 루트경로가 localhost/FJsp 이므로
			http://localhost/FJsp/sample/sample.jsp 로 접속할 수 있다.
==================================================================================
	XML
		Extensible Markup Language의 약자로 
		확장성 있는 마크업 언어라고 이야기한다.
		
		태그를 이용해서 파일의 내용을 구분하도록 만들어지는 문서를 말하며
		이중에 HTML문서도 있따.
		
		이때 HTML의 경우는 사용자는 태그가 이미 결정이 되어 있지만
		xml은 사용자가 태그의 종류를 정한 후 그 태그를 이용해서 문서를 만든느 것을 말한다.
		
		이 문서는 주로 프로그램의 환경 설정을 하기 위한 목적으로 많이 사용되는 문서이다.
		
		프로그램은 프로그램으 실행하기 전
		먼저 설정파일(xml)을 읽은 후
		그 파일의 태그를 분석한다.
		==> 분석하는 이 작업을 "파싱한다" 라고 말한다.
		그리고 그 파싱된 결과를 프로그램에서 이용하는 과정을 거친다.
		
		***
		결론적으로 어떤 프로그램의 실행환경(시작환경)을 바꾸고 싶으면
		우리는 xml파일에서 그 환경을 설정하는 부분을 찾아서 수정하면 된다.
		
		참고]
			파싱을  하기 위해서는 그 xml 문서에 있는 태그의 의미를 알아야 한다.
			xml문서를 만드는 사람이 태그의 순서, 의미를 지정해 놓은 문서가 별도로 존재한다. 
			이 문서를 DTD혹은 "스키마문서" 라고 한다.
		
	환경설정
		1. welcome 파일 수정하기
			welcome 파일 : 클라이언트가 파일이름을 지정하지 않을 경우 
							자동적으로 응답할 파일을 이야기한다.
			방법]
				1. web.xml파일에서
				2. <welcome-file-list> 태그를 수정한다.
		2. 호스팅하기
			==> 평소는 www.naver.com과 같이 도메인 이름으로 접속하는데
				우리는 http://localhost/FJsp/...를 사용한다.(혹은 아이피주소)
				
				그 이유는 우리는 도메인이 없기 때문에
				서버를 구분해주는 아이피를 입력하고 웹서비스를 해주는 서버에 접근을 해서
				컴퓨터 자기자신을 가리키는 예약어가 localhost이므로
				실제 서비스 되고 있는 웹 서버처럼 요청을 하려면
				먼저 도메인이 등록이 되어야 하고
				만약 도메인이 등록이 있다면
				다음 방법으로 하면 된다.
					
					1. 도메인 등록을 하고
					2. 특정 IP를 가진 컴퓨터에 톰캣을 설치한다.
					3. server.xml 파일에서
						<Context docBase="FJsp" path="/FJsp" reloadable="true" 
						source="org.eclipse.jst.jee.server:FJsp"/></Host>
						여기서 path 부분을 수정한다.
						
						<Context docBase="FJsp" path="/" reloadable="true" 
						source="org.eclipse.jst.jee.server:FJsp"/></Host>
==============================================================================================
****JSP구조
		JSP는 응답문서(주로 HTML문서)를 만들기 위한 언어의 일종이다.
		따라서 HTML 문서가 중심이 되고
		그리고 추가적으로 자바적인 요소가 필요하면 포함될 수 있다.
			==>	JSP는 자바적인 요소를 포함할 수 있는 스크립트 언어
			
	HTML과의 차이점
		HTML은 서버측에서 실행이 불가능하고
		오직 클라이언트(웹 브라우저)에서만 실행이 가능한 언어이다.
			==> 이미 준비된 문서로 응답하는것 뿐 수정이 불가능하다.
	
	JSP는 서버측에서 실행할 수 있는 언어이다.
		==> 요청이 올때마다 서버측에서 실행을 해서
			새로운 HTML문서를 제작을 할 수 있다.
			요청이 올 때마다 내용 변화를 시킬 수 있다.
	
	JSP구조에서 반드시 알아야 할 내용
		1. 자바적인 요소를 어떤 방식으로 HTML문서 안에 넣을것인가?
			==> <% %>, <%=변수 %>
		2. 지시자
			==> JSP문서의 특징이나 처리방식을 지시하는 명령
			
			형식]
				<%@ 명령어 속성=값 속성=값...%>
			
			명령어 종류]
				page 	- 문서 자체의 특성이나 처리방식을 지시하는 명령
				include - 문서 안에 다른 문서를 포함하도록 지시하는 명령
				taglib  - 사용자가 제작한 태그를 사용할 수 있도록 선언하는 명령
			
			a. page명령
				==> 지금 만드는 문서 자체에 특성이나 처리방식을 지시하는 명령
				1) language
					==> 스크립트할 언어의 종류를 지정하는 속성
						지금까지는 오직 자바언어만 허락하는 상태
						생략하면 자동으로 Java를 스크립트 해준다.
						
						<%@ language="java" %>
						
				2) extends
					==> JSP는 실행을 하면 내부적으로 자바 클래스로 변환되고,
						그 후 실행된다.
						(즉, 중간단계의 언어로 바뀐 상태에서 실행을 하므로
						ASP,PHP보다 실행속도가 빠르다는 장점이 있다.)
						
						이때 중간에서 만들어지는 클래스가 어떤 클래스를 상속받아서
						만들지를 지정하는 속성
						
						이미 jsp 문서가 클래스로 변환될때 HttpJspBase라는 클래스를 
						상속받아서 만들도록 셋팅이 되어있다.(생략해도)
						
						그런데 자바는 다중상속이 불가능하므로 필요없는 속성이다.
						
						<%@ page extends="javax.servlet.jsp.HttpJspBase" %>
				*	
				3) import
					==> 스크립트 안에 자바적인 요소글 넣을 수 있는데
						이 때 사용하는 자바적인 요소를 특정 패키지 소속이면
						자바와 동일하게 반드시 import 시켜야 한다.
						그 작업을 해주는 속성
						
						<%@ import="java.util.*" %>
						
						참고]
							여러개를 한번에 임포트 가능하다.
							<%@ import="java.util.*, java.text.*" %>
							
				4) session
					==> 세션의 사용 여부를 판단하도록 하는 속성
						생략하면 세션을 사용하도록 한다.(기본이 True)
										
						<%@ page session="true" %>
				
				5) buffer
					==> 내부적으로 버퍼를 사용할지 여부와
						버퍼의 크기를 얼마로 할지 여부를 지정하는 속성
						생략하면 기본값으로 8KByte를 버퍼로 사용한다.
						
						<%@ page buffer="none" %>
						==> 버퍼를 사용하지 않겠다.
						<%@ page buffer="16K" %>
						==> 버퍼의 사이즈를 16KByte로 지정.
					
					참고]
						버퍼란 클라이언트에게 서버가 응답을 할때
						처리속도를 빠르게 하기 위해서 중간에 
						버퍼를 사용해서 데이터를 모았다가 한번에 출력하는 구조
						
				6) autoFlush(다 차지 않으면 꺼낼 수 없는데, 억지로 꺼내오는 명령)
					==> 자동 flush 기능을 사용할지 여부를 가리키는 속성
						생략하면 true가 지정되고 자동 flush기능이 실행된다.
						
						<%@ page autoFlush="true" %>
						
					참고]
						JSP의 모든 문서는 자동 스레드 처리가 된다.
						false 설정한다면 반드시 강제로 flush를 시켜줘야 한다.
						
				7) isThreadSafe
					==>	쓰레드처리를 할때 동기화 처리 여부를 설정하는 속성
						
						<%@ page isThreadSafe="true" %>
						
				8) info
					==> 주석문에 해당하는 속성
						실행에는 아무런 상관이 없고
						문서에 대한 정보(주석)를 입력하고 싶을 경우 사용하는 속성
						
						<%@ page info="여기는 설명페이지.."%>
				*		
				9) errorPage
					==> JSP문서를 실행하는 도중 문제(Exception)가 발생하면
						그 문서로는 응답을 해줄 수가 없다.
						그래서 대신 응답할 다른 문서를 지정하는 속성
						
						<%@ page errorPage="myError.jsp" %>
							==> 에러가 발생하면 대신 myError.jsp 로 
								클라이언트에게 응답하라.
				 
				*
				10) isErrorPage
					==> 지금 만드는 페이지가 에러 페이지용 문서인지를 지정하는 속성
						
						<%@ page isErrorPage="true" %>
						
				*		
				11) contentType
					==> 실행결과 응답 방식을 지정하는 속성
						
					참고]
						실행결과 탄생하는 문서의 종류를 지정할 수 있다.
						이때 응답문서의 종류는 MIME Type으로 지정해야 한다.
						
						<%@ page contentType="text/html" %>
							==> 실행결과 응답문서의 형식은 html 문서다.
					
						
				12) pageEncoding
					==> 문자 인코딩 방식을 지정하는 속성
					
						<%@ page pageEncoding="UTF-8" %>
					참고]
						contentType에서 인코딩 방식을 지정할 수 있으므로 생략해도 무방
				
				
			b. include 명령
				==> 다른 문서를 현재 파일에 포함시키는 기능을 가진 지시어
					그래서 하나의 파일로 만드는 기능
					
					<%@ include file="합칠 파일 이름" %>
				
				참고]
					우리가 홈페이지를 만들다 보면 여러페이지에 같은 내용이 중복되는 경우가 많이있다.
					하지만 원칙적으로 JSP문서가 만든 결과를 응답하기 때문에 
					매 문서마다 동일한 내용이라도 다시 써줘야 한다.
					
					이런 불편함을 조금이나마 덜기 위해 방법으로 제시된 지시어
					
				결론]
					자주사용하는 내용은 따로 만들어놓고 
					응답문서의 따로 만들어진 파일을 합쳐서 하나의 문서로 만드는 방법
				
				** 
				이 작업은 두 문서를 합치고(하나의 문서로 만들고) 컴파일을 한다.(클래스로 만든다)
				만약 먼저 합쳤을때 문제가 생기면(충돌이 나면) 에러가 발생한다는 것을 명심하자.
				
			c. taglib 명령
				==> 사용자가 제작한 태그를 사용할 수 있도록 선언하는 명령
				
		스크립트방식
			1. 스크립트 릿 방식
				==> 일반적인 자바 언어를 포함하는 방식을 의미한다.
					이곳에 기록한 모든 내용은 service 함수 안에 포함된다.
					그러므로 이곳은 결국 직역적인 역할을 한다.
				참고]
					어차피 JSP문서는 여러 문서가 같이 실행되는 것이 아니고
					클라이언트가 요청한 문서 하나만 실행되므로
					클래스가 연결되어서 실행되는 경우는 거의 없다.
					결론적으로 main 함수만 있으면 충분하게 그 역할을 한다.
				
				참고]
					JSP문서는 실행을 하면 먼저 자바 클래스로 변환되고
					변환된 것을 실행하는 방식이다.
					실행할때 자바의 main함수처럼 시작함수가 존재하는데
					그 함수가 service 함수이다.
				
				스크립트 릿 방식 형식]
					<%
						자바 처리 명령
					%>
				참고]
					스크립트 릿 속에 있는 내용과 HTML 내용은 같이 service 함수에 코딩된다.
					그러므로 두가지는 혼용해서 사용할 수 있다.
					다만 자바요소와 HTML요소만 구분을 해주면 된다.
					
			2. 선언자 방식
				==> JSP는 service 함수안에서 거의 모든것이 실행된다.
					하지만 가끔 전역변수나 함수가 필요한 경우가 
					발생하면 전역변수와 함수를 만드는 방식이 선언자 방식
					
				결론]
					전역변수와 함수를 만드는 기능을 가진 스크립트 방식
					(이 안에서는 일반적인 명령은 사용을 할 수 없다.)
					
				형식]
					<%!
						변수선언
						함수제작
					%>
			
			3. 표현자 방식
				==> System.out.println() 과 같이
					자바적인 요소(변수, 함수)를 화면에 내용을 출력하기 위한 스크립트
					
				형식]
					<%= 출력내용 %>
				
				주의사항]
					출력내용은 오직 한개만 출력을 할 수 있따.
					이것은 System.out.println() 도 마찬가지이다.
					==> 문자열 결합을 이용해서 하나의 문자열로 바꿔서 
						오직 한개의 문자열을 출력하는 방식
			
			참고]
				주석문
					1. 확장자가 html인 문서(HTML)
						<!-- -->
					2. jsp
						//, /**/
				
						
		내장 객체		
			==> 자주 사용하는 클래스중 몇가지는 
				JSP안에서 미리 new 시켜서 사용할수 있도록 준비해놓은것이다.
				그러므로 이것은 new 시킬 필요 없이
				필요한 순간에 시용할수 있는 클래스를 내장객체라 한다.
			
			1. out 객체
				
				PrintWriter 클래스를 미리 new 시켜놓은 내장객체
				
				즉, PrintWriter out = new PrintWriter(??);
				
				이 클래스의 역할은 
				클라이언트에게 응답하는 문서를 작성하도록 하는 기능
				
				주요함수 
					write()
					flush()
				PrintWriter는 JSPwriter 클래스로 변환되어서 new 된 경우이다.
				
			2. request 객체
				==> 클라이언트의 요청 정보를 관리하는 역할을 하는 내장 객체
					즉, 요청한 클라이언트의 IP주소, 요청내용, 부가정보를 알고 싶은 경우
					사용하는 내장객체.
				HttpServletRequest 클래스를 이용해서 만들어진 내장객체
				
				주요함수]
					getParameter()
					==>	서버측에서 클라이언트가 요청한 부가정보를 알아내는 함수
						형식]
							String ???	 = getParameter("키값");
						
						문제점]
							부가정보는 오직 문자열로만 받을 수 있다.
							getParameterValues()
							형식]
								String[] ??? = getParameterValues("키값");
									
		참고]
			클라이언트가 서버에게 요청하는 방법
				1. GET
					1) 주소표시줄에 직접 입력해서 요청하는 방법
					2) <a> 태그를 이용해서 요청하는 방법
						형식]
							<a href="????">내용></a>
				2. POST
					==> 요청정보가 헤더에 포함이 되서 요청하는 방식
					
					1) form태그를 만들어서 요청하는 방법
						==> 로그인 폼과 같이 사용자가 필요한 것을 입력 또는 선택해서 
							서버에게 전달하는 방식
						
						***
						특징]
							a.
								전달할 내용을 반드시 form 태그 안에 만들어야 한다.
								(<== form 태그 자체를 넘기기 떄문에...)
								만약 어떤 폼이 <form>태그 안에 있지 않으면
								그 내용은 서버에 전달되지 않는다.
							
							b.
								서버에서는 전달된 내용을 받아야 하는데..
								이떄 name이라는 속성값을 키값으로 받게 된다.
								따라서 폼태그를 만들때는 반드시 name 속성을 지정해야 한다.								
							
							c. 
							
					***
					참고]
						이때 반드시 이 폼의 내용을 전달할 도구를 준비한다.
						이 도구를 우리는 submit(번역을 하자면 "제출") 도구라고 한다.
						
						제출 도구를 만드는 방법
							1. html로 해결하는 방법
								<input type="submit" value="버튼">
								==> 이 태그는 버튼을 만등러주는 태그인데
									이때 주의해야할 사항이
									이 버튼을 클릭하게 되면 폼에 입력한 내용을
									서버에 제출하게 된다.
									이 버튼에 속해있는 form태그를 제출하게 된다.
									
									<form id="frm1" method="post" action="주소1">
										<input type="text" id="in1">
										<input type="submit" value="btn1">
									</form>

									<form id="frm2" method="post" action="주소2">
										<input type="text" id="in2">
										<input type="submit" value="btn2">
									</form>
			
									이런 경우
									btn1을 클릭하게 되면
									frm1만 제출하게 된다.(버튼이 소속되어있는 폼태그만 제출됨)
							
							2. javascript로 해결하는 방법
								<script>
									var f = 폼태그 선택;
									f.submit();
								</script>
								<form method="post" action="주소">
									필요한 입력태그
								</form>
								
								참고]
									중요속성]
										method : 폼의 데이터를 서버에게 보내는 방식
										action : 서버가 받을 문서이름
								참고]
									Post 방식은 스트림을 이용해 서버에게 전달하므로
									주소칸에 내용이 나오지 않는다(get보다 보안상 유리)
						참고]
							post방식으로 데이터 전송시 한글깨짐 방지방법
							서버가 필터링을 이용해 인코딩 해줘야함
							방법]
								web.xml을 열어서
								1. 필터를 만들고
									<filter>
										<filter-name>Encoding Filter</filter-name> // 필터의 이름을 정하는 태그
										<filter-class>en.filter.EncodingUtil</filter-class> // 필터에 사용할 
										<input-param> // 한글 인코딩방식을 정하는 태그
											<param-name>encoding</param-name>
											<param-value>UTF-8</param-value>
										</init-param>
									</filter>
									==> 이 태그는 web.xml 에서 기본적으로 제공하는 태그이고
										이 태그를 찾아서 주석을 해제를 해주면 된다.

								2. 필터를 적용한다.
										<filter-mapping>
											<filter-name>Encoding Fileter<filter-name>
											==> 적용할 필터 이름을 지정하는 태그
												위에서 만든 필터이름을 기술한다.
											<url-pattern> /* </url-pattern>
											==> 어떤 요청이 왔을 때 필터를 적용을 할 건지 설정하는 태그
												모든 요청에 대해서 필터를 적용하고자 한다면
															/*
												해주면 모든 요청에 적용이 된다.
										</filter-mapping>
										==> 이 부분을 찾아서 주석을 해제해준다.
							
							*****
							참고]
								<form> 태그르 전송할 때
								모든 태그가 전송이 되는 것이 아니고
								입력계열 태그만 전송한다.
									input, textarea 태그를 전송한다.
								
								그런데 화면에 보이는 내용을 전송하는 것이 아니고
								value 속성에 지정한 내용이 서버에게 전달이 된다.
								따라서 입력태그의 value속성은 반드시 만들어 줘야 한다.
											<input type="text" value="xx">
								*****
								만약 입력태그를 전송용도로만 제작을 하고 
								화면에 보이지 않게 하려면
								type속성값을 hidden으로 처리하면 된다.
							
							참고]
								만약 같은 폼 안에 같은 name이 여러개 존재하는 경우에는
								모든 데이터가 배열 형식으로 전달된다.
								
								따라서 이때는
									request.getParameterValues();
								함수를 사용해서 전송을 받는다.
							
							참고]
								라디오, 체크박스의 경우
								선택된 내용만 서버에 전달이 된다.
								
								
												
			